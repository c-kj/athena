<comment>
# 一些描述
# 这个文件是我的 input file 的模板。把所有可能的参数都写进去，然后根据需要注释掉不需要的部分。
# 目前默认取 GM_BH=1, R_out=1, rho_init=1 的归一化单位制，这样 t_ff = 1。
problem   = CKJ TEMPLATE
reference =
configure = --prob turb+BH_accretion -hdf5 -fft -mpi --cxx=icpx # 未名二号
configure = --prob turb+BH_accretion -fft --fftw_path="/opt/homebrew/opt/fftw" -hdf5 --hdf5_path="/opt/homebrew/opt/hdf5" -omp -debug --cxx="clang++" --cflag="-O3 -flto -march=native" # 我的 Mac


<job>
problem_id = TEMPLATE    # 输出文件的 basename。常用的有: Bondi, SN,

<output1>
file_type  = hst         # History data dump
dcycle     = 1           # 每个步长都输出。hst 文件应该不会太大，所以可以很密集。

<output2>
file_type  = hdf5        # HDF5 Output 是主要的输出数据
dt         = 0.01        # time increment between outputs  # dt 适当大一点，避免输出过多
variable   = prim        # variables to be output  # 只输出主变量 prim，cons 变量由后处理计算，减小输出体积
id         = prim        # output id

<output3>
file_type  = rst         # Restart File，用于断点续算
dt         = inf         # time increment between outputs  # 若设为 inf，则只输出初始和最终的 Restart File

<time>
cfl_number = 0.3         # The Courant, Friedrichs, & Lewy (CFL) Number
nlim       = -1          # cycle limit # -1 代表无穷大
tlim       = 2.          # time limit  # 总时间要比 t_freefall 更长
integrator  = vl2        # time integration algorithm
xorder      = 2          # order of spatial reconstruction
ncycle_out  = 1          # interval for stdout summary info


# 注意在计算区域的两侧留出足够的额外空间，至少要 2*dx，这样方便计算散度、旋度等
<mesh>
nx1        = 64          # Number of zones in X1-direction
x1min      = -1.1        # minimum value of X1
x1max      =  1.1        # maximum value of X1
ix1_bc     = outflow     # inner-X1 boundary flag
ox1_bc     = outflow     # outer-X1 boundary flag

nx2        = 64          # Number of zones in X2-direction
x2min      = -1.1        # minimum value of X2
x2max      =  1.1        # maximum value of X2
ix2_bc     = outflow     # inner-X2 boundary flag
ox2_bc     = outflow     # outer-X2 boundary flag

nx3        = 64          # Number of zones in X3-direction
x3min      = -1.1        # minimum value of X3
x3max      =  1.1        # maximum value of X3
ix3_bc     = outflow     # inner-X3 boundary flag
ox3_bc     = outflow     # outer-X3 boundary flag

refinement     = adaptive  # AMR
numlevel       = 5         # AMR 的最大层数（root = 1, 和 SMR 不同）
derefine_count = 5         # derefine 前的时间步数

# refinement     = static    # SMR（目前不启用）
# refinement     = none      # 均匀网格（目前不启用）

num_threads = 8            # OpenMP 并行线程数。MPI 并行时需要注释掉这一行


<meshblock>             # CHANGEME: meshblock 的大小，注意要能被 Root Grid 整除
nx1        = 32
nx2        = 32
nx3        = 32


# SMR 的细化区域 （目前不启用）
# <refinement1>
# x1min      = -0.5
# x1max      = 0.5
# x2min      = -0.5
# x2max      = 0.5
# x3min      = -0.5
# x3max      = 0.5
# level      = 1


<hydro>
gamma           = 1.666666666667   # gamma = C_p/C_v   # 取 gamma = 5/3，单分子气体，绝热
# iso_sound_speed = 1.00           # equivalent to sqrt(gamma*p/d) for p=0.1, d=1


<turbulence>      # 这里的 n 实际上是 L/λ，即区域内包含的波的个数。对应的物理尺度为 λ = L/n in code units
dedt       = 10   # Energy injection rate (for driven) or Total energy (for decaying)
nlow       = 0    # cut-off wavenumber at low-k    # 最低为 1，对应物理尺度为 L （这里可以取到 0 或负数，应该是指包含了所有更大尺度？）
nhigh      = 16   # cut-off wavenumber at high-k   # 最高为 1/2 * nx (Nyquist 频率，对应物理尺度为 2*dx)
expo       = 2.0  # power-law exponent
tcorr      = 0.1  # correlation time for OU process (both impulsive and continuous)
dtdrive    = 0.1  # time interval between perturbation (impulsive)
f_shear    = 0.5  # the ratio of the shear component
rseed      = -1   # if non-negative, seed will be set by hand (slow PS generation)


<problem>
turb_flag  = 0         # 1 for decaying, 2 (impulsive) or 3 (continuous) for driven turbulence
GM_BH = 1
R_in = 0.1             # CHANGEME: Sink radius 需要根据最小网格的大小来调整
R_out = 1              
rho_in_BH = 1e-4
rho_init = 1
E_tot_init = 400.0     # CHANGEME: 初始总能量


<debug>
debug = 0                  # 控制 debug 的输出等级


<AMR>                      # 我自定义的 AMR 参数
time_start_AMR = 4         # AMR 的开始时间

<AMR/point>                # 这里的 level 和 SMR 的 level 概念一致，root=0. 而 <mesh> 的 numlevel 则是 root=1，因为这是 level 的数目
point_1 = 0.0, 0.0, 0.0
level_1 = 5
point_2 = 0.0, 0.0, 0.0
level_2 = 5

###### TODO 有待实现 ######
<initial_condition>
init_cond_type = uniform   # 可选值："uniform", "power_law", "approximate_Bondi", "rotation"
# rho_at_boundary = 1.   # 暂时不用这个，而是用 <problem> 里的 rho_init
# E_tot_at_boundary = 1. # 暂时不用这个，而是用 <problem> 里的 E_tot_init
power_law_index = -1.5   #?
alpha = 0.333

<supernova>
SN_flag = 1                           # 控制 SN 的开关

SN_1_time = 0.0, 0.2                  # 爆发的时间列表。可选格式：单个时间（0.3）；多个时间的列表（.0, .2, .4, .6）
SN_1_energy = 1.0                     # 单次注入的总能量，默认为 0
SN_1_mass = 0.0                       # 单次注入的总质量，默认为 0
SN_1_center = 0.0, 0.0, 0.0           # region 的中心，默认在原点
SN_1_radius = 0.01                    # region 的半径
# SN_1_mass_center = 0.0, 0.0, 0.0      # 可以单独指定 mass_region 的中心和半径。如果不指定，则与 energy_region 一致
# SN_1_mass_radius = 0.0                
# SN_1_region = ball                    # energy_region 和 mass_region 的种类。可选值：ball, heart
# SN_1_velocity = 0.0, 0.0, 0.0         # SN 本身运动的速度



